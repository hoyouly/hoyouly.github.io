---
layout: post
title: 扫盲系列之---TCP/IP,Socket,HTTP,HTTPS
category: 扫盲系列
tags: TCP/IP Socket HTTP HTTPS
---
* content
{:toc}

## 网络分层：
从底往上依次是：
物理层->数据链路层->网络层->传输层->会话层->表示层->应用层  

|名称|协议 |作用|
|:----|:------|:------|
|物理层|RJ45、CLOCK、IEEE802.3 （中继器，集线器）|通过媒介传输比特，确定机械及电气规范，（比特bit）|
|数据链路层|PPP,FR,HDLC,VLAN,MAC(网桥，交换机)|将比特组装成帧和点到点的传递（帧Frame）|
|网络层|IP,IMCP,RP,RARP,OSPF,IPX,RIP,IGRP.(路由器)|负责将数据包从源到宿的传递和网际互联（包packet）|
|传输层|TCP，UDP，SPX|提供端到端的可靠报文和错误恢复（段 Segment）|
|会话层|NFS,SQL,NETBIOS,RPC|建立，管理和终止会话，（会话协议数据单元SPDU）|
|表示层|JPEG,MPEG,ASCII|对数据进行加密，翻译和压缩，（表示协议数据单元PPDU）|
|应用层|FTP,HTTP,DNS,SMTP,WWW,NFS,Telnet|运行范文OSI环境手段（应用协议数据单元APDU）|

每一个上层基于地下一层。
IP协议 位于网络层
TCP协议 位于传输层
所以TCP协议基于IP协议的，又因为TCP协议与IP协议互补，所以经常说TCP/IP 协议   

访问一个网络，整个过程其实就是： 连接-> 请求-> 应答-> 关闭连接。 这四个流程
1. 通过三次握手建立连接
2. 通过发送报文请求
3. 返回报文进行应答
4. 通过四次挥手关闭连接

先说几个名词，后面会用到
## 位码
TCP标志：
* SYN (synchronous 建立链接)
* ACK (acknowledgement 确认)
* PSH (push 传送)
* FIN (finish 完成)
* RST (reset 重制)
* URG （urgent 紧急）
* Seq (Sequence Number 顺序号码)
* ACK (Acknowledgement number 确认号码)

## 建立连接 --> TCP/IP 三次握手
三次握手的原因就是为了防止已经失效的连接请求报文段突然又传送到服务端，从而产生错误。
流程如下：
![](https://github.com/hoyouly/BlogResource/raw/master/imges/tcp_three_hand.png)

* 第一次握手，客户端尝试连接服务器，向服务器发送SYN报文。
* 第二次握手，服务器收到SYN报文后，会发送SYN+ACK报文，表示确认收到。此时服务器进入SYNC——RECV状态
* 第三次握手，客户端收到服务器的SYN+ACK包，向服务端发送确认包ACK，表示我已知倒。此包发送完毕，客户端和服务器进入ESTABLISHED 状态，完成三次握手

解释：
1.  为了保证服务端能接受客户端的的信息并且能做出正确的应答而进行前两次（第一次和第二次）握手，为了能保证客户端能接收到服务端的信息并且能做出正确的应到而进行后两次（第二次和第三次）握手。
2.  第三次握手是为了防止服务器端一直等待而浪费自己的时间，而不是为了保证客户端能够正确响应服务器的回应
3.  三次握手不是为了TCP本身的要求，而是为了满足 在不可靠信道上可靠的传递信息这需求导致的。

## HTTP
基于TCP/IP 协议的一种封装，他有一个很明显的特点：与服务器建立连接后，你请求服务器，服务器会给你响应。

## 请求 --  应答 --> HTTP的报文
HTTP的报文有两种
* 请求报文---从客户端向服务器发送的报文
* 响应报文---从服务器到客户端的回答  

![](https://github.com/hoyouly/BlogResource/raw/master/imges/http_message_formate.png)

请求报文和响应报文都是由三部分组成
* 开始行  用于区分请求报文还是响应报文，请求报文的开始行叫请求行（request-line）,响应报文的开始行叫状态行（status-line）,在开始行的三个字段都是以空格隔开，最后以CR和LF分别表示回车和换行
* 首部行  用来说明浏览器，服务器或报文的一些信息，首部可以有好几行，也可以没有，在每一个首部行中都有首部字段名和值，每一行在结束的位置都要有回车和换行，整个首部行结束后，还有一个空行用来区分首部行和实体主体
* 实体主体  在请求报文中一般都不用这个字段，而在相应报文中也可能没有这个字段。

HTTP 通信的过程就是出栈和入栈的过程

![](https://github.com/hoyouly/BlogResource/raw/master/imges/http_commite.jpeg)
报文从 应用层到传输层，传输层通过TCP三次握手建立连接，四次挥手释放连接

## 关闭连接 --> TCP四次挥手
由于TCP是全双工模式，因此每个通道都必须单独进行关闭，这个原则是：当一方完成了他的数据发送任务后就发送一个FIN来终止这个方向的连接，收到一个FIN只意味着一方没有数据流通，一个TPC连接收到一个FIN后仍能发送数据，首先进行关闭的一方将主动关闭，另一方被动关闭
TCP的连接的断开需要发送四个包,因此称为四次挥手（four-way handshake）,客户端和服务器均可发起挥手动作，在socket编程中，任何一方执行了close()操作即发起挥手操作

![](https://github.com/hoyouly/BlogResource/raw/master/imges/tcp_four_bye.png)

1. 客户端发送一个FIN，表示客户端已经没有数据要发送给服务器了，要断开与服务端的连接，但是这个时候，客户端是可以收到服务端的数据的。
2. 服务端收到这个FIN，他发回一个ACK，表示服务端知道了客户端要断开连接。
3. 服务端发送FIN 报文， 表示服务端也没有数据要发送给客户端了， 要关闭与客户端的连接，
4. 客户端收到FIN报文，并发ACK报文进行确认。



## TCP UDP区别
1. TCP面向连接，如打电话，UDP面向无连接，如广播
2. TCP提供可靠情报，也就是说通过TCP传输的数据，无差错，无重复，无丢失，并且按照顺序到达，UPD则尽最大努力交付，即不能保证可靠交付
3. TCP面向字节流，即TCP把数据看成是一串无结构的字节流。UDP面向报文的，UDP无阻塞控制，所以就不会因为网络堵塞导致源主机发送速率降低，对实时很有帮助，如IP电话，实时视频会议等
4. 每一条TCP只能点对点，UDP支持一对一，一对多和多对多的互相通信
5. TCP 首部开销20字节，UDP 首部开销小，8字节
6. TCP的逻辑通信信道是全双工的可靠信道，UDP的shi不可靠信道。


## Socket
对协议的一种抽象，是使用协议的最小单元。是对TCP/IP的一种封装，当然Socket还可以指定其他协议，例如UDP，我们可以直接new 一个Socket对象，但是却不能new 一个TCP/IP
可以理解为某种规定，TCP/IP 相当于公司规章制度，Socket相当于劳动合同

## 建立Socket链接
建立Socket链接至少需要一对套接字，其中一个运行到客户端，叫做ClientSocket，另一个运行在服务器端，称为ServerSocket，
套接字之间的链接过程分为三个步骤:
* 服务器监听 ： 服务端套接字并不定位具体的客户端套接字，而是处于等待链接状态，实时监听网络状态，等待客户端套接字的请求
* 客户端请求  ： 客户端套接字提出链接请求，要链接的目标是服务端套接字，为此客户端套接字必须要描述它链接的服务端套接字的，支出服务端套接字的端口和IP，然后向服务端套接字提出请求。
* 链接确认  ：  当服务端套接字监听到或者接收到客户端套接字的请求时，就相应客户端套接字的请求，建立一个新的链接，把服务端的套接字的描述发送给客户端套，一旦客户端确认了此描述，双方就正式建立链接，而服务端套接字依旧处于监听状态，继续接受其他客户端套接字的链接请求。


## HTTP与Socket
HTTP是轿车，提供了封装或显示的具体形式
Socket是发动机，提供了网络通信能力

传输层的TCP是基于网络层的IP协议的
应用层的HTTP又是基于传输层的TCP协议的
Socket 本身不算是协议，只是提供了真的TCP或UDP编程的接口


## HTTPS
由SSL和HTTP协议构建的可加密传输，身份认证的网络协议，以安全为目的的HTTP通道，基础是SSL，需要到CA申请认证书，一般免费比较少，因而需要一定的费用。
完全不同的连接方式，端口也不一样，HTTP 端口是80，HTTPS的端口是443

这套证书就是 一对公钥和私钥，
HTTP 协议传输数据是通过明文显示的
HTTPS 是通过SSL或者TLS加密处理数据，更安全

网上看了一些资料，例如信鸽解释HTTPS，还有其他的一些，最终自己画了一个类似的流程图，有请大名鼎鼎的小明同学登场。

![](https://github.com/hoyouly/BlogResource/raw/master/imges/https_flow.png)

小明同学 要和小红同学通信，
1. 小明同学给小红同学寄一个信鸽，但是不带任何信息，
2. 小红同学收到小明同学的信鸽，然后找一个老师买了一个带锁的盒子, 这个一般都是提前买好的。
3. 小红同学就用信鸽把这个盒子捎过去了，这个时候盒子是没锁的，开着的
4. 小明同学收到这个盒子，会找老师确认，这个是不是小红买的盒子，
5. 老师通过各种方式确认是小红的盒子，没有经过任何改变。
6. 小明同学就会把加密方式放到这个盒子中。然后锁上盒子让信鸽带给小红
7. 小红同学收到上锁的盒子，拿着唯一的钥匙（私钥），打开这个盒子，得到加密方式，
8. 这样小红和小明同学都有了加密方式，就可以通过对称加密，先加密，然后发送数据，对方再解密，得到数据，加密，发送加密数据，解密，这样就可以愉快的聊天了，中间就算数据被别人拿到了，可是只要加密方式足够复杂，就能保证数据的安全。

这里面的小明同学就是客户端，小红同学就是服务端，老师就是CA，
服务器会提前向CA买证书，证书就是一对秘钥，公钥（带锁的盒子）和私钥（钥匙），
每个证书是唯一的，都是带有过期日期和序列号，申请者的姓名等，然后把这些进行数字签名，修改任何一个地方就会导致数字签名不一致的。
把一段文字和私钥进行数字签名，然后把消息和数字签名发给客户端

---
搬运地址：  
[HTTP和HTTPS协议，看一篇就够了](https://blog.csdn.net/xiaoming100001/article/details/81109617)   
[Android中的TCP/IP协议，Socket，Http协议间的关系](https://blog.csdn.net/u010618194/article/details/62439168)   
[Android客户端面试基础(四)-TCP/IP](https://blog.csdn.net/johnWcheung/article/details/72835044)   
[用信鸽来解释 HTTPS](https://www.oschina.net/translate/https-explained-with-carrier-pigeons)   
[深入浅出HTTPS基本原理](https://blog.csdn.net/kobejayandy/article/details/52433660)   
