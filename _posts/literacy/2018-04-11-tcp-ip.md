---
layout: post
title: 扫盲系列 - TCP/IP
category: 扫盲系列
tags: TCP/IP
---
* content
{:toc}

## 网络分层：

### OSI 参考模型
* 一个尝试让世界计算机互联为一个网络的概念性框架，
* 只是一个参考模型，并没有提供具体的实现方法或者标志，
* 换而言之，他是一个为了定制标准提供参考的概念性框架。
* 更像是一个行为规范，贴近生活的例子就是一个企业的企业文化。

从底往上依次是：
物理层->数据链路层->网络层->传输层->会话层->表示层->应用层  

|名称|协议 |作用|
|:----|:------|:------|
|物理层|RJ45、CLOCK、IEEE802.3 （中继器，集线器）|通过媒介传输比特，确定机械及电气规范，（比特bit）|
|数据链路层|PPP,FR,HDLC,VLAN,MAC(网桥，交换机)|将比特组装成帧和点到点的传递（帧Frame）|
|网络层|IP,IMCP,RP,RARP,OSPF,IPX,RIP,IGRP.(路由器)|负责将数据包从源到宿的传递和网际互联（包packet）|
|传输层|TCP，UDP，SPX|提供端到端的可靠报文和错误恢复（段 Segment）|
|会话层|NFS,SQL,NETBIOS,RPC|建立，管理和终止会话，（会话协议数据单元SPDU）|
|表示层|JPEG,MPEG,ASCII|对数据进行加密，翻译和压缩，（表示协议数据单元PPDU）|
|应用层|FTP,HTTP,DNS,SMTP,WWW,NFS,Telnet|运行范文OSI环境手段（应用协议数据单元APDU）|

说明：
* 每一个上层基于下一层。
* IP协议 位于网络层
* TCP协议 位于传输层
* HTTP协议 位于应用层

网络数据结构模型，

![](../../../../../article-detail/images/network_data_model.png)

从图可知，上一层的数据加上头部，封装到下一层的数据中。


### TCP/IP 参考模型
TCP/IP 协议 代表整个网络传输协议家族，而不仅仅是TCP和IP协议，TCP协议和IP协议是该家族中最早最核心的的两个协议标准，因此该协议家族被称为TCP/IP 协议家族
也就是我们常说的TCP/IP 协议，

这个有点像是 淘宝就代表电商的感觉，其实搞电商的不仅仅是淘宝，还有京东，苏宁等。

|名称|解释 |OSI 参考模型|
|:----|:------|:------|
|网络连接层|主机与网络相连的协议，如：以太网|物理层和数据链路层|
|网络互联层|IP 协议和 ICMP 协议等，负责数据的路由的选择与数据转寄|网络层|
|传输层|TCP 协议和 UDP 协议等，控制端对端的连接、流量和稳定性|传输层|
|应用层  |HTTP、FTP、SMTP 和 SSH 等，粗犷的理解为程序员层|会话层、表达层和应用层|

* HTTP 协议是TCP/IP 参考模型中应用层的一种实现。
* HTTP协议 网络层是基于IP协议，传输层是基于TCP协议

这就是我们说的 HTTP 协议是基于 TCP/IP 协议的应用层协议
## TCP IP 数据结构
### IP 数据结构模型

![](../../../../../article-detail/images/http_data_model.png)
IP 头部占32位， IPV4 的 IP 地址是用点式十进制表示的，例如：192.168.1.1，在 IP 头部用二进制表示的话，刚好是 4 个字节 32 位。


### TCP 数据结构模型

![](../../../../../article-detail/images/tcp_data_model.png)

#### 位码
TCP标志：
* SYN (synchronous 建立链接)
* ACK (acknowledgement 确认)
* PSH (push 传送)
* FIN (finish 完成)
* RST (reset 重制)
* URG （urgent 紧急）
* Seq (Sequence Number 顺序号码)
* ack (Acknowledgement number 确认号码)

### TCP 三次握手
三次握手的原因就是为了防止已经失效的连接请求报文段突然又传送到服务端，从而产生错误。
流程如下：
![](../../../../../article-detail/images/tcp_three_hand.png)

* 第一次握手，客户端尝试连接服务器，向服务器发送SYN报文。 从最开始的close状态，进入`SYN_SEND`状态
  用恋爱过程 就是  A男对女的说： 我爱你  
* 第二次握手，服务器收到SYN报文后，会发送SYN+ACK报文，表示确认收到。此时服务器进入SYNC——RECV状态       
  女的对A男的说，我收到了你的爱，我也爱你。
* 第三次握手，客户端收到服务器的SYN+ACK包，向服务端发送确认包ACK，表示我已知倒。此包发送完毕，客户端和服务器进入ESTABLISHED 状态，完成三次握手。   
  A男的对女的说，我也收到了你的爱。

解释：
1.  为了保证服务端能接受客户端的的信息并且能做出正确的应答而进行前两次（第一次和第二次）握手，为了能保证客户端能接收到服务端的信息并且能做出正确的应到而进行后两次（第二次和第三次）握手。
2.  第三次握手是为了防止服务器端一直等待而浪费自己的时间，而不是为了保证客户端能够正确响应服务器的回应
3.  三次握手不是为了TCP本身的要求，而是为了满足 在不可靠信道上可靠的传递信息这需求导致的。
4. 第三次握手的时候，可以携带。前两次握手不能携带数据。

### TCP 四次挥手
由于TCP是全双工模式，因此每个通道都必须单独进行关闭，这个原则是：当一方完成了他的数据发送任务后就发送一个FIN来终止这个方向的连接，收到一个FIN只意味着一方没有数据流通，一个TPC连接收到一个FIN后仍能发送数据，首先进行关闭的一方将主动关闭，另一方被动关闭
TCP的连接的断开需要发送四个包,因此称为四次挥手（four-way handshake）,客户端和服务器均可发起挥手动作，在socket编程中，任何一方执行了close()操作即发起挥手操作

![](../../../../../article-detail/images/tcp_four_bye.png)

1. 客户端发送一个FIN，表示客户端已经没有数据要发送给服务器了，要断开与服务端的连接，进入 `FNI_WAIT_1` 状态 ，但是这个时候，客户端是可以收到服务端的数据的。
2. 服务端收到这个FIN，他回一个ACK，表示服务端知道了客户端要断开连接。进入 `CLOSE_WAIT` 状态，客户端收到后进入 `FIN_WAIT_2` 状态
3. 服务端发送FIN 报文， 表示服务端也没有数据要发送给客户端了， 要关闭与客户端的连接，进入`LAST_ACK` 状态
4. 客户端收到FIN报文，进入 `TIME_WAIT` 状态，然后 回应ACK报文进行确认。等待服务端（时间是2 个 MSL） 可能要求重传 ACK 包，因为服务端收到后关闭连接，进入 CLOSED 状态或者要求客户端 重传 ACK，客户端在一定的时间内没收到服务端 重传 ACK 包的要求后，断开连接进入 `CLOSED` 状态
 注：等待服务端时间 是 2 个 MSL(Maximum Segment Lifetime，报文最大生存时间), 在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。

#### 等待2MSL的意义
因为发完最后ACK后，可能服务端还有数据在路上，如果不等待，直接CLOSE状态，那么就可能造成数据丢失。并且如果新的应用刚好占用了这个端口，就给新的应用带来了无用的数据包，造成数据混乱。

为啥是两次呢?
* 一次是为了保证四次挥手中主动关闭放最后ACK报文最终能达到对方
* 一次是为了保证对方没收到ACK重传FIN报文可以达到。
用一个例子能说明一下：

小明使用公共电话给小红打电话。如果电话传输时间为1分钟，也就是说小明的话，一分钟后小红才听得到。这是前提。
挂断电话的时候
小明说，`我准备挂掉电话了`，  这个时候只是准备，并没有挂掉，
一分钟后
小红收到小明的  `我准备挂掉电话了` 话语，小红显示回应一句说，`我知道你想挂断电话了`，然后又说了一句，`我也没啥要说的了，挂掉吧`
小明收到小红回应的那句 `我知道你想挂断电话了`, 但是这个时候他还没挂断，因为小明只是知道了自己请求得到了响应，但是还不确定小红还不想挂断电话啊
终于，收到了小红的`我也没啥要说的了，挂掉吧`, 这个时候，小明回复一句`好的`，但是这个时候小明并没有立即挂断，因为他不知道路上还有没有其他的小红的话语。如果立即挂断，万一还有路上还有小红的话没传递过来，那不就数据丢失了吗。
所以他需要等待。等待多久呢。两分钟
一分钟时间，这句`好的`传到小红那里，然后等待小红的指令，如果再过一分钟后没有收到小红的话，那就说明小红真的没啥指令了。可以挂掉了。


#### 为啥是四次挥手，而不是三次挥手
因为客户端收到FIN后，往往不会立即返回FIN，必须要等到所有的数据报文都发送完之后，才会发FIN，先发送一个ACK告诉客户端，我收到了你的FIN，等忙完手里的工作才会再给你发FIN，
这个有点像是领导让你做一个必要但是不紧急的任务，你收到领导的安排后，回复说，我收到了，忙完手里的活在做你这件事。

如果四次挥手变成三次挥手，也就是服务端的ACK 和FIN 合并成一个，那么就会导致客户端长时间收不到服务端返回的数据，以为服务端没收到，然后重发FIN。

## TCP UDP区别
1. TCP面向连接，如打电话，UDP面向无连接，如广播
2. TCP提供可靠情报，也就是说通过TCP传输的数据，无差错，无重复，无丢失，并且按照顺序到达，UPD则尽最大努力交付，即不能保证可靠交付
3. TCP面向字节流，即TCP把数据看成是一串无结构的字节流。UDP面向报文的，UDP无阻塞控制，所以就不会因为网络堵塞导致源主机发送速率降低，对实时很有帮助，如IP电话，实时视频会议等
4. 每一条TCP只能点对点，UDP支持一对一，一对多和多对多的互相通信
5. TCP 首部开销20字节，UDP 首部开销小，8字节
6. TCP的逻辑通信信道是全双工的可靠信道，UDP的shi不可靠信道。


关于 HTTP和HTTPS 的请参考下一篇 [扫盲系列 - Socket,HTTP,HTTPS](../../../../../article-detail/2019/12/20/http-https/)

---
搬运地址：    

[HTTP和HTTPS协议，看一篇就够了](https://blog.csdn.net/xiaoming100001/article/details/81109617)   

[Android中的TCP/IP协议，Socket，Http协议间的关系](https://blog.csdn.net/u010618194/article/details/62439168)   

[Android客户端面试基础(四)-TCP/IP](https://blog.csdn.net/johnWcheung/article/details/72835044)   

[用信鸽来解释 HTTPS](https://www.oschina.net/translate/https-explained-with-carrier-pigeons)   

[深入浅出HTTPS基本原理](https://blog.csdn.net/kobejayandy/article/details/52433660)   

[(建议收藏)TCP协议灵魂之问，巩固你的网路底层基础](https://juejin.im/post/5e527c58e51d4526c654bf41)  
 
[HTTP 协议理解及服务端与客户端的设计实现](https://yanzhenjie.blog.csdn.net/article/details/93098495)
