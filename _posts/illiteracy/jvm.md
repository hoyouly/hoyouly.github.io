---
layout: post
title: 扫盲系列之---jvm
category: 扫盲系列
tags:jvm
---
* content
{:toc}


话题：简单描述下jvm的垃圾回收策略，比如引用计数、标记清除等策略
关键字：引用计数、标记清除、gc

# 垃圾回收机制的意义
垃圾回收机制是Java中一个显著的特点。可以有效的防止内存泄漏。有效的使用内存空间
**内存泄漏** 是指该内存空间使用完毕之后没有回收，在不涉及复杂数据结构的情况下，Java的内存泄漏表现为一个对象的生命周期超出了程序需要他的时间长度。

# 垃圾回收机制的算法。
Java语言没有明确规定JVM 使用的哪种GC算法，但是任何一种GC算法一般都要做两件事
* 发现无用信息对象
* 回收被无用信息占据的内存空间，使该内存空间可以被再次使用。

## 引用计算法（Refrence Counting Collector）
GC 的早期算法，当在堆中创建一个对象，这个对象有一个引用计数，当赋值给一个变量的时候，该计数为1，当有新的变量引用该对象的时候，计数加1，例如 a=b,则b引用的对象实例计数加一，当该对象实例的引用 超过了的生命周期或者赋予了新的值时候，该对象实例减一，任何引用计数为0的都可以被当做垃圾收集，当一个对象实例当做垃圾收集时，他引用的任何对象实例的计数减一。
### 优缺点
优点: 引用计数器可以很快的执行，交至在程序运行中。对程序需要不被长时间打断的环境有利
缺点：无法检测出循环引用。如父对象有一个子对象引用，子对象又一个父对象引用，那么他们的计算器永远不为0

## tracing 算法(tracing collctor)或者标记清除算法（mark and sweep）
### 根搜索算法
![](http://p5sfwb51p.bkt.clouddn.com/gc_root_search_collector.png)
从离散数学图论引入，把所有的引用看成一张图，从一个节点的GC Root 开始找，找到对应引用节点，再从引用节点开始找，继续搜索这个引用节点对应的节点，这样搜索下来，当所有的引用节点寻找完毕，剩余的节点就是被认为没有引用的节点，即无用的节点  
Java中可以作为GC Root的对象有
1. 虚拟机栈中引用的对象（本地变量表）
2. 方法区中静态属性的引用对象
3. 方法区中常量引用对象
4. 本地方法栈中引用对象（Native 对象）

### tracing 算法示意图
![](http://p5sfwb51p.bkt.clouddn.com/tracing_collctor_1.png)

### 标记算法分析
标记算法采用从根集合进行扫描，对存活对象进行标记，标记完成后，再扫描整空间未被标记的，然后进行回收，标记清除算法不需要对对象进行移动，并且对不存活的对象进行处理，在存活对象较多的情况下极为有效，但是直接回收不存活的对象，会造成内存碎片化严重。

## compacting 算法 或者标记整理算法
![](http://p5sfwb51p.bkt.clouddn.com/compacting_collector.png)
和标记清除算法类似，也是标记对象，但是在清除时不同，在回收不存活对象之后，会将所有存活对象往左端空闲k空间移动，并更新指针。在标记清除算法上做了改进，增加了对象移动，因此成本变高，但是解决了内存碎片化的问题。在基于compacting算法的收集器的实现中，一般增加了句柄和句柄表

## copying 算法

![](http://p5sfwb51p.bkt.clouddn.com/copyting_collector.png)
克服 了句柄开销和解决了堆碎片问题。它开始把堆分成一个对象面和多个空闲面，程序从兑现面为对象分配空间，当对象满了，算法就收集从根集中扫描的活动对象，然后将每个活动对象copy到空闲面（使得活动对象所占的空间没有空间洞）。这样空闲面就变成了对象面，原来对象面就变成了空闲面。程序在新的对象面分配内存。一种典型的基于Copy 算法的就是stop-and-copy 算法，将堆分成对象面和空闲面，在对象面和空闲面切换的时候，程序暂停执行。

## generation 算法，
![](http://p5sfwb51p.bkt.clouddn.com/generation_collctor.png)
分代垃圾回收策略：基于这样一个事实，不同的对象生命周期不一样，因此不同生命周期对象应该采用不同的回收算法，一遍提高回收率
### 年轻代（Young Generation）
1. 所有新生对象首先放到年轻代。年轻代的目标就是尽快的收集那些生命周期短的对象
2. 年轻代的内存按照8：1：1 分为一个eden（社区） 区和两个survivor（幸存，剩余）(survivor0和survivor)区。大部分对象再eden区，回收时先将eden区存活对象copy一个servior0 区，然后清空eden区，当这个survivor 0区也满后，把eden区和survivor0区的存活对象copy到survivor1 区，清空eden区和survivor0 区，此时survivor0 区为空，然后把survivor0区和survivor1区交换，始终保持survivor1区为空，如此往复。
3. 当survivor1 区不足以存放survivor0和eden区存活对象时，就将存活对象放入到老年代，若老年代也满了就会触发一次full GC，也就是新生代和老年代都会进行回收。
4. 新生代发生GC叫Minor GC ,这个频率比较高，不一定等到eden满时候才发生。

### 老年代 (Old Generation)
1. 新生代发生几次GC后仍旧存活下来的对象，会放入老年代，可以认为老年代中存放的都是一些生命周期比较长的对象
2. 内存也比新生代大的很多（大概是2：1），当老年代内存满时候会触发Minor GC ,即full GC，这个频率较低，老年代对象存活时间较长，存活率标记高
### 持久代(Permanent Generation)
用于存放静态文件，如java类，方法等，持久代对GC没有显著影响，但是有些应用可能动态生成或者调用一些class文件，例如Hibernate等，在这种时候需要设置一个较大的持久空间来存放这些运行中生成的类。

# GC执行机制
由于对象进行了分代处理，因此GC区域，时间不一样，GC 有两种类型，Scavenge GC 和Full GC

## Scavenge GC
一般情况下，当新对象生成，并且在eden申请对象失败时，就会触发Scavenge GC ,对Eden区进行GC，清除非存活对象，并且把尚存活对象copy到Survivor0 区，然后整理两个survivor区，这种方式对年轻代的eden区域进行，不会影响到老年代。因为大部分对象都是从eden区开始的，同事eden区不会分配很大，所以eden区的GC频繁发生，因此这里需要速度快，效率高的算法，使Eden区域尽快空闲出来

## Full GC
对整个堆进行整理，包括年轻代，老年代和持久代，因为需要对整个堆处理，所以比Scavenge GC慢，因此尽可能减少Full GC次数，在对JVM调优中，很大一部分工作就是对Full GC的调节，有如下原因导致full GC
1. 年老代被写满
2. 持久代被写满
3. System.gc()被调用
4. 上一次GC后heap的各域分配策略动态变化

# Java 有GC依旧造成内存泄漏
1. 静态集合类像HashMap Vector等使用最容易造成内存泄漏，这些静态变量的生命周期和应用程序一样，所有的对象也就不能被释放，因为他们也将一直被HashMap,Vector等引用着
2. 各种连接，数据库连接，网络连接，IO连接等没有显示调用close方法关闭，不被GC回收导致内存泄漏
3. 监听器的使用，在释放对象的同时没有相应删除监听器的时候也导致内存泄漏。


---
搬运地址：  
[深入理解java垃圾回收机制----](http://www.cnblogs.com/sunniest/p/4575144.html)  
[Java虚拟机垃圾回收(一) 基础：回收哪些内存/对象 引用计数算法 可达性分析算法 finalize()方法 HotSpot实现分析](https://blog.csdn.net/tjiyu/article/details/53982412)  
