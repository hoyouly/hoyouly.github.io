---
layout: post
title: 扫盲系列之---jvm 的垃圾回收
category: 扫盲
tags: jvm
---
* content
{:toc}

# 垃圾回收
Garbage Collection  GC ： 自动管理回收不在引用的内存数据  
现在使用GC技术的语言有Java，Perl，LM等

## 为啥还需要了解GC
目前内存的动态分配和GC技术相当成熟，为啥还要了解呢
1. 当需要排查各种内存泄露，内存溢出的问题时
2. 当GC成为系统达到更高并发量的瓶颈时  

这就需要对这些自动化技术实现必要的监听和调节

# GC的意义
垃圾回收机制是Java中一个显著的特点。可以有效的防止内存泄漏。有效的使用内存空间
**内存泄漏** 是指该内存空间使用完毕之后没有回收，在不涉及复杂数据结构的情况下，Java的内存泄漏表现为一个对象的生命周期超出了程序需要他的时间长度。

# GC算法要做的事情。
Java语言没有明确规定JVM 使用的哪种GC算法，但是任何一种GC算法一般都要做三件事
1. 那些内存需要回收，即如何判断对象已经死亡
2. 什么时候回收，即GC发生什么时候，需要了解GC策略，与垃圾回收器实现
3. 如何回收，需要了解GC算法，以及算法实现--垃圾回收器

# 判断对象可回收算法
## 引用计数算法（Refrence Counting Collector）
GC 的早期算法，  
给对象添加一个引用计数器，  
当有新变量引用这个对象的时候，该计数器加一  
当引用失效或者超过声明周期时，计数器减一  
任何时刻计数器为0，则认为该对象不再被使用，可以被当做垃圾收集。

### 优缺点
优点: 引用计数器可以很快的执行，交至在程序运行中。对程序需要不被长时间打断的环境有利
缺点：
* 无法检测出循环引用。如父对象有一个子对象引用，子对象又一个父对象引用，那么他们的计算器永远不为0
* 开销大，频繁并且大量的引用变化，打来大量的额外运算
主流的JVM都没有选取计数算法管理内存

## 可达性分析算法
### 基本思路
从离散数学图论引入，把所有的引用看成一张图， 从一个节点的GC Root 开始找，找到对应引用节点，再从引用节点开始找，继续搜索这个引用节点对应的节点，这样搜索下来，当所有的引用节点寻找完毕，剩余的节点就是被认为没有引用的节点，即无用的节点  
搜索所走过的路径称为引用链（Reference chain）  
![](http://p5sfwb51p.bkt.clouddn.com/gc_root_search_collector.png)

Java中可以作为GC Root的对象有
1. 虚拟机栈中引用的对象（本地变量表）
2. 方法区中静态属性的引用对象
3. 方法区中常量引用对象
4. 本地方法栈中引用对象（Native 对象）  

主要执行在上下文中和全局性的引用
### 优缺点
优点： 更加精确严谨，可以分析出循环数据结构互相引用情况
缺点：
* 实现复杂
* 需要分析大量数据，消耗大量时间
* 分析过程需要GC停顿，因为应用关系不能发生改变，即停顿所有java线程，称为stop the world 是垃圾回收重点关注的问题

# 判断对象是生存还是死亡
宣告一个对象真正死亡，至少需要两次标记过程。
## 第一次标记
在发现到GC Root没有任何引用链相连的时候，被第一次标记
并且进行第一次筛选，此对象是否必要执行finalize()方法：
* 有必要执行
  1. 对象没有覆盖finalize()方法
  2. finalize()方法已经被JVM调用了  
这两种情况都可以认为对象已经死亡，可以被回收
* 没必要执行
  先放入到F-Queue队列中，稍后在JVM自动建立的，优先级低的Finalizer线程（可能是多个）中触发这个方法

## 第二次标记
GC将对F-Queue 队列中的对象进行第二次小规模标记
finalize()方法是对象跳脱死亡的最后一次机会
* 如果对象在finalize()方法中重新了与引用链中任何一个对象建立关联，第二次标记会把该对象移除"即将回收"集合
* 如果对象没有，也可以认为对象已死，可以回收
一个对象的finalize()方法只会被系统自动调用一次，经过Finaliz()方法逃脱死亡的对象，第二次不会再调用；

## finalize()
上面说过finalize()方法与GC第二次标记相关，
* finalize()方法是Object类的一个方法，是java刚诞生时候，为了让C/C++程序员容易接受它做的一个妥协，但是不要把这个当成C/C++的析构函数,因为它执行时间不确定，甚至是否执行都不确定（java 程序的不正常退出），而且运行代价高，无法确保各个对象的调用顺序 ，如果需要释放资源，可以定义显示的终止方法，并且在try-catch-finally的finally{}中保证及时执行，如File类的close方法
* 一般情况下，应尽量避免使用它，甚至可以忘掉它

### finalize()用途
1. 充当 安全网
当显示的终止方法没有调用时，在finalize()方法中发出警告，但要考虑值得付出这样的代价，如FileOutStream,FileInStream,Timer和Connection类都有这样应用
2. 与对象的本地对等体有关。
本地对等体： 普通对象调用本地方法委托的本地对象
本地对等体不会被GC回收，如果本地对等体不拥有关键资源，finalize()可以回收它，如果拥有关键资源，必须显示终止

# GC 算法
JVM常见的GC算法： 标记清除算法，复制算法，标记整理算法，分代收集算法和火车算法
## 标记清除算法分析
标记算法采用从根集合进行扫描，对存活对象进行标记，标记完成后，再扫描整空间未被标记的，然后进行回收，标记清除算法不需要对对象进行移动，并且对不存活的对象进行处理，在存活对象较多的情况下极为有效，但是直接回收不存活的对象，会造成内存碎片化严重。
### 标记清除算法示意图
![](http://p5sfwb51p.bkt.clouddn.com/tracing_collctor_1.png)
### 优缺点
* 优点： 基于最基础的可达性分析算法，是最基础的标记收集算法，后续的算法都是在此基础上对其不足改进的
* 缺点: 主要有两点:
  1. 效率不高，标记和清除效率都不高
  2. 空间问题，产生大量内存碎片，这会导致分配大内存对象时，无法找到足够的内存。从而需要提前触发另外一次GC操作

### 应用场景
针对老年代的CMS收集器

## copying 算法
为了解决标记清除算法d 效率问题。克服 了句柄开销和解决了堆碎片问题。
### 算法思路
1. 把内存划分两个大小相等的快，每次只使用一块
2. 当该快内存使用完了，就将该内存中存活的对象复制到另外一块区域，然后使用这一块
3. 把已使用的内存块一次性清理掉，然后重复步骤2 操作。

### 示意图
![](http://p5sfwb51p.bkt.clouddn.com/copyting_collector.png)

### 优缺点
* 优点： 使得每次都针对半个区域进行回收。内存分配时候不必考虑碎片化等问题
* 缺点：
  1. 空间浪费，可用内存是原来的一般，太过浪费，（可以改良，不按照1：1划分）
  2. 效率随存活对象的升高而降低，当对象存活率较高的时候，需要更多的copy操作，效率变低，（后面的标记整理算法可以解决这个问题）

### 应用场景
现在商业JVM 都是采用这种算法（通过改良缺点1）来回收新生代  
如Serial 收集器，ParNew 收集器，Parallel Scavenger 收集器，G1（从局部看）

### HotSpot 虚拟机改良算法
HotSpot VM， Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。
#### 弱代理论
分代垃圾收集基于弱代理论（weak generation hypothesis），具体描述如下
1. 大多数分配了内存的对象存活不会太长，出在年轻代就会死掉
2. 很少有对象从年老代变成年轻代

其中IMB研究表明，98%对象都是朝生夕死，所以并不需要按照1：1 划分内存。
#### HotSpot VM 新生代内存布局和算法
1. 将新生代内存分为一个较大的Eden区和两个较小survivor 区，
2. 每次使用Eden 区和其中一个survivor区
3. 当回收时，将Eden区和使用的survivor区中存活的对象复制到另一个survivor区
4. 清空Eden区和之前使用的那个Survivor区
5. 后面就使用Eden区和复制到的那一个Survivor区，重复步骤3，  
默认Eden : Survivor 是8：1 ，即每次可以使用的空间是90%，只有一块Survivor区被浪费
#### 分配担保
如果另一块Survivor区域没有足够的空间存放上一次新生代存活下来的对象，这些对象将直接通过分配担保机制（Handle Promotion）进入年老代，若老年代也满了就会触发一次full GC，也就是新生代和老年代都会进行回收。


## compacting 算法 或者标记整理算法
根据老年代的特点提出来的。
### 算法思路
1. 标记，和标记清除算法一致
2. 整理，在回收不存活对象之后，会将所有存活对象往左端空闲k空间移动，并更新指针。

### 示意图
![](http://p5sfwb51p.bkt.clouddn.com/compacting_collector.png)

### 优缺点
* 优点：
  1. 不会想Copy 算法那样，效率随存活率升高而降低，  
      老年代的特点：对象存活率高，没有额外的空间可以分配担保，所以老年代不采用copy 算法，而是采用标记整理算法
  2. 不会像标记清除算法那样，产生大量内存碎片，因为清除前，都做了整理，存活对象集中到了一侧。

* 缺点： 除了像标记算法那样标记外，还得需要整理的过程，效率更低
### 应用场景
很多垃圾收集器采用这种方式回收老年代。例如 Serial Old 收集器，G1(从整体上看)

## generation 算法，

![](http://p5sfwb51p.bkt.clouddn.com/generation_collctor.png)
分代垃圾回收策略：基于这样一个事实，不同的对象生命周期不一样，因此不同生命周期对象应该采用不同的回收算法，以便提高回收率，所以就结合不同的收集算法处理不同的区域，
### 算法思路
基于前面说的弱代理论，根据对象存活周期的不同把内存划分几个区域，这样就可以根据各个年代的特点采用最适当的GC算法，一般把Java堆分为年轻代和老年代以及持久代

### 年轻代（Young Generation）
所有新生对象首先放到年轻代。年轻代的目标就是尽快的收集那些生命周期短的对象，每次GC都会有大量对象死去，只有少量存活，新生代发生GC叫Minor GC ,这个频率比较高，不一定等到eden满时候才发生。  
所以可以采用copy 算法

### 老年代 (Old Generation)
1. 新生代发生几次GC后仍旧存活下来的对象，会放入老年代，可以认为老年代中存放的都是一些生命周期比较长的对象
2. 内存也比新生代大的很多（大概是2：1），当老年代内存满时候会触发Minor GC ,即full GC，这个频率较低，老年代对象存活时间较长，存活率标记高
3. 对象存活率高，没有额外的空间进行分配担保，可以使用标记整理或者标记清理算法

### 持久代(Permanent Generation)
用于存放静态文件，如java类，方法等，持久代对GC没有显著影响，但是有些应用可能动态生成或者调用一些class文件，例如Hibernate等，在这种时候需要设置一个较大的持久空间来存放这些运行中生成的类。
### 优缺点
* 优点： 可以根据不同的年代采用最合适的算法
* 缺点： 仍不能控制每次垃圾收集时间

### 应用场景
目前几乎所有的商业虚拟机的垃圾收集器都采用分代收集算法，
如 HotSpot虚拟机上全部的垃圾收集器： Serial，ParlNew,Parallel Scavenge,Serial Old,Parallel Old, CMS,G1 等
## 火车算法
也叫列车算法，是一种更彻底的分区域处理收集算法，是对分代收集算法的一个补充。
### 算法思路
在火车算法中，内存被分为块，多个快组成一个集合，为了形象化，一个车厢代表一个快，一列火车代表一个集合，如下图：
火车和车厢都按照创建顺序标号，每个车厢大小相等，但是火车包含的车厢数不相等，
每节车厢有一个记忆集合，而整个火车的记忆集合是素有车厢的记忆集合的总和，
记忆集合由组成车厢对象的引用组成，这些引用来着同一个车厢中序号较高的车厢中对象，以及序号较高的对象
垃圾收集以车厢为单位，整体流程如下
1. 选择序号较小的火车
2. 如果火车记忆集合为空，释放整列火车并终止，否则执行步骤3
3. 选择火车中标号较小的车厢
4. 对于车厢中记忆集合的每个元素。
  * 如果它是被一个根引用的对象，那么将copy到一列新火车上
  * 如果是一个被其他火车对象指向的对象，那么将它copy到指向它的火车上去
  * 如果有一些对象已经保留，那么通过这些对象可以触及到的对象将会copy到同一火车上去
  * 如果一个对象被来自多个火车上的对象引用，那么可以将它copy到任何一个火车上
  这个步骤，有必要对受到影响的引用进行更新
5. 释放车厢并终止。
收集的时候会删除一些空车厢和空车，并在需要的时候，创建一些车箱和火车。
### 示意图
![](http://p5sfwb51p.bkt.clouddn.com/huoche_collector.png)
### 优缺点
* 优点： 可以在成熟对象空间提供限定时间的渐进收集，而不需要每次都进行大区域的垃圾回收过程，即可以控制垃圾回收时间，在指定时间内进行小区域的回收
* 缺点： 实现比较复杂，如采用类似算法的G1收集器直到JDK7才实现，一些场景下性价比不高
### 应用场景
JDK7后的HotSpot VM的G1 收集器采用了类似算法，能建立可预测的停顿时间模型。

# GC执行机制
由于对象进行了分代处理，因此GC区域，时间不一样，GC 有两种类型，Scavenge GC 和Full GC

## Scavenge GC
一般情况下，当新对象生成，并且在eden申请对象失败时，就会触发Scavenge GC ,对Eden区进行GC，清除非存活对象，并且把尚存活对象copy到Survivor0 区，然后整理两个survivor区，这种方式对年轻代的eden区域进行，不会影响到老年代。因为大部分对象都是从eden区开始的，同事eden区不会分配很大，所以eden区的GC频繁发生，因此这里需要速度快，效率高的算法，使Eden区域尽快空闲出来

## Full GC
对整个堆进行整理，包括年轻代，老年代和持久代，因为需要对整个堆处理，所以比Scavenge GC慢，因此尽可能减少Full GC次数，在对JVM调优中，很大一部分工作就是对Full GC的调节，有如下原因导致full GC
1. 年老代被写满
2. 持久代被写满
3. System.gc()被调用
4. 上一次GC后heap的各域分配策略动态变化

# Java 有GC依旧造成内存泄漏
1. 静态集合类像HashMap Vector等使用最容易造成内存泄漏，这些静态变量的生命周期和应用程序一样，所有的对象也就不能被释放，因为他们也将一直被HashMap,Vector等引用着
2. 各种连接，数据库连接，网络连接，IO连接等没有显示调用close方法关闭，不被GC回收导致内存泄漏
3. 监听器的使用，在释放对象的同时没有相应删除监听器的时候也导致内存泄漏。

---
搬运地址：  
[深入理解java垃圾回收机制----](http://www.cnblogs.com/sunniest/p/4575144.html)  
[Java虚拟机垃圾回收(一) 基础：回收哪些内存/对象 引用计数算法 可达性分析算法 finalize()方法 HotSpot实现分析](https://blog.csdn.net/tjiyu/article/details/53982412)  
[Java虚拟机垃圾回收(二) 垃圾回收算法：标记-清除算法 复制算法 标记-整理算法 分代收集算法 火车算法](https://blog.csdn.net/tjiyu/article/details/53983064)
