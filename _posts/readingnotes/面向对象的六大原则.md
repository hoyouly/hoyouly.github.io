# 优化代码的第一步--单一职责原则
两个完全不一样的功能就不应该放在一个类中。
一个类中应该是一组相关性很高的函数,数据的封装。
根据具体的业务，功能对类进行相应的拆分，这是程序员优化代码的第一步。
# 让程序更稳定，更灵活--开闭原则
软件中的对象（类，模块，函数等）应该对于扩展是开放的，但是对于修改是封闭的。当软件需要变化是，我们应该尽量通过扩展的方式来实现变化。而不是同修改已有的代码来实现。
依赖注入，把需要改动的地方抽取出来成一个接口，让不需要改变的地方使用这个接口对象，

# 构建扩展性更好的系统--里氏替换原则
所有引用基类的地方必须能够透明的使用其子类的对象。
通俗的讲只要父类能出现的地方子类就可以出现，并且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。
核心原理是抽象，抽象又依赖于继承这个特性。
# 让项目拥有变化的能力--依赖倒置原则
一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节的目的。依赖模块被颠倒了，
关键点：
1. 高层模块不应该依赖于底层模块，两者都应该依赖其抽象，
2. 抽象不应该依赖于细节
3. 细节应该依赖于抽象

在java语言中，抽象就是指接口或者抽象类，两者都不能直接被实例化的;细节就是实现类，实现接口或继承抽象类而产生的类就是细节。
高层模块 就是调用端，底层模块就是具体实现类。
模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系通过接口或者抽象类产生。

# 系统有更高的灵活性--接口隔离原则
类间的依赖关系应该建立在最小的接口上。接口隔离原则将非常庞大，臃肿的接口拆分成更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的放，
让客户端依赖的接口尽可能地小，
目的：
# 更好的扩展性--迪米特原则
最少知识原则，一个对象应该对其他对象有最少的了解。
只与直接的朋友同学，

# Builder模式
一步一步创建复制对象的创建型模型，他允许用户在不知道内部构建细节的情况下，可以更精密的控制对象的创建过程。该模式为了将构建复杂对象的过程和它的内部解耦，使得构建过程和部件的表示隔离开来。

## ViewRootImpl
继承Handler，是作为native层与java层View系统通信的桥梁，比如我们熟悉的performTracversals函数就是收到系统绘制View的消息之后，通过调用视图树的各个节点的meatrue,layout,draw方法来绘制整个视图树的，
