---
layout: post
title: 数据结构和算法之美--复杂度分析
category: 数据结构和算法
tags: 数据结构 算法
---
* content
{:toc}
任何一个知识点，都要做到 **“是什么，为什么，怎么做”**


## 复杂度分析
占据数据结构和算法的半壁江山，是数据结构和算法学习的精髓。
数据结构和算法解决的是如何更快更省的存储和处理数据的问题。因此我们就要有一个考量效率和资源消耗的标准。这个就是复杂度分析方法

### 为啥需要复杂度分析

不用具体测试数据来测试，就可以粗略估计算法执行效率的方法，这就是时间，空间复杂度分析方法
所有代码的执行事件T(n)与每行代码的执行次数成正比

T(n)=O(f(n))
T(n): 代码执行的时间
n： 数据规模大小
f(n):每行代码执行的次数总和
O ：代码执行时间T(n)和f(n)成正比

大O表示法：代码执行时间随数据规模增长的趋势。
当n很大的时候，就可以忽略并不左右的，例如变量，低阶，系数等，只关注最大的阶数就好



每一行都执行类似操作： 读数据-运算-写数据


时间复杂度，就是你代码运行的多少次

1. 只关注循环次数最多的一段代码
2. 加法法则，总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则，嵌套代码的复杂度等于嵌套内外代码复杂度的乘积


## 常见的时间复杂度实例分析
### 多项式量级
* 常量阶 O(1)
* 对数阶 O(logn)
* 线性阶 O(n)
* 线性对数阶 O(nlogn)
* 平方阶 O(n^2), 立方阶 O(n^3)... K次方阶 O(n^k)
### 
* 指数阶 O(2^n)
* 阶乘阶 O(n!)



```java
for (int i = 0; i < n; i=i*2) {
    System.out.println(n);
}
```
假设循环次数是t，那么循环条件必须满足 2^t <n  即 t=log(2)(n)  以2为低n的指数。所以时间复杂度就是O(log(2)(n)),即时间复杂度是O(log(n)


什么是算法

1+2+3+...+n
 for(i=1;i<n;i++){
   sum+=i;
 }
 n越大，计算次数越多，时间复杂度是O(n)

 方法二  sum=n*(n+1)/2  这个就是算法，不管n是多少，我只计算一次,即时间复杂度是O(1)

```java
public int fib(int n){
      if(n==0||n==1){
          return 1;
      }
      return fib(n-1)+fib(n-2);
  }
```
递归类型，时间复杂度是O(2^n)











===
